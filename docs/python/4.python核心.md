### python核心

##### 1.python中一切皆对象

- 这里讲的python都是cpython (即解释器是cpython)
- python中一切皆对象，class,函数也是对象。类也是对象，我们可以动态的修改它的属性
- 函数和类也是对象，属于python中的一等公民
- 一等公民：1.赋值给一个变量 2.可以添加到集合对象中 3.可以作为参数传递给函数 4.可以当作函数的返回值
- python中is判断对象的地址是否相同， == 判断值是否相同
- 尽量使用 isinstance 判断类型，而不是type
- 涉及到IO操作,才有同步,异步,阻塞和非阻塞的说法

```python
# 判断一个对象是否是整型
import numbers

isinstance(1, numbers.Integral)

```

##### 元组拆包

```python
# tuple元组可以进行拆包
date_str = '2020-4-5'
year, mouth, day = tuple(date_str.split('-'))
print(year)     # 2020
print(mouth)    # 4
print(day)      # 5
```



##### 1.将函数赋值给一个变量

```python
# 1.定义一个函数
def ask(name="bobby"):
  print("name")

# 2.将函数赋值给一个变量
my_func = ask

# 3.这个变量即可以当作函数使用
my_func()
```

##### 2.将类赋值给一个变量

```python
# 1.创建一个类
class Person:
  def __init__(self):
    print('person')

# 2.将这个类赋值给一个变量
my_person = Person

# 3.通过变量实例化对象
my_person()
```

##### 3.将函数和类，添加到集合中（1.2中的函数和类）

```python
# 1.将类和函数，添加进列表
'''
以下代码执行结果
name              函数的输出        
None              print(item())输出，因为函数没有返回值，所以打印None
person            类的__init__方法的输出
<__main__.Person object at 0x000002C7FC888320>    print(item())输出，返回类对象
'''
obj_list = []
obj_list.append(ask)
obj_list.append(Person)
for item in obj_list:
  print(item())
```

##### 5.将函数作为函数的返回值（python中适器的原理）

- 函数和类可以作为函数的返回值
- 函数和类可以作为函数的参数

```python
# 1.定义一个函数
def hello():
  print("hello word")

# 2.定义一个函数，将上面的函数的作为这个函数的返回值
def nice():
  print("nice")
  return hello

# 3.调用nice函数，返回值仍然是函数
he = nice()

# 4.执行返回的函数
he()
```

##### 6.type object class 的关系

###### type

- type的两种用法：1.返回一个对象的类型   2.生成一个类
- type  class obj   （type生成类对象，类对象生成实例对象）
- type即是对象也是类
- type将所有的对象都生成出来，例如函数，类，对象
- 所以为什么说函数和类等一切都是对象，是因为它们都是由type创建出来的，是type的实例
- 为了python的灵活性，把所有的东西都设置成对象，那么当我们的类创建之后，也可以往里面修改或者增加属性函数等，因为类也属于对象，而对象可以修改属性，其他类似

```python
# 演示 type ——> int ——> 1   (type生成int, int生成数字1)
type(1)				# class' int			整数的类型是int
type(int)			# class' type			int的类型是type,int这个类型是由type生成的

# type ——> class ——> obj	(type生成class, class生成对象)  
type('nice')		# class 'str'

# 自定义的类，它的type也是属于type
class Studnet:
    pass
stu = Student()
type(stu)		 	# class 'student'
type(Student)		# class 'type'
```

###### Object

- object是一个所有类都要继承的基础类
- type也是类它继承自object,同时type又将自己实例化成对象，并且把object等其他也实例化成对象
- 所以type(object) 的结果是type         type.__base杠杠 的结果是object
- 打印父类

```python
class Student:					# 它的父类(基类)是object, 继承关系 Studnet -> object
	pass
print(Student.__bases__)		 # 打印父类 __bases__		

class Parent(Student):			# 它的父类是Student,继承关系 Parent -> Student -> object 
    pass

# type即是对象也是类,以下形成循环引用
# type得父类是object
# object的类型又是type,即object是由type生成
# 原因：object是最顶层的基类，而type是类，所以被object管. type管对象，而object既可以说是类，也可以说是对象所以被type管到

type.__bases__				    # object (type的父类使object)
type(object)					# class 'type'
```

##### 7.python中常见的内置类型

- None (全局只有1个)
- 数值   int float complex bool
- 迭代类型 (迭代器和生成器中讲解)
- 序列类型   list  bytes  range  tuple  str array
- 映射 dict   (set 和 dict的实现原理都是一样的，所以它们的效率非常高)
- 集合  set  fronzenset(不可修改的set)
- 上下文管理类型   with（关键字）

- 其他类型（涉及到python源码，这里不再深入进行讲解）
  - 模块类型
  - class和实例
  - 函数类型
  - 方法类型
  - 代码类型（代码也会被python解释器当作一个对象类型）
  - object类型
  - type类型
  - ellipsis类型

- 对象的三个特征：
  -  身份（对象在内存中的地址，id函数查看）
  - 类型（任何一个对象都有类型，比如 12 是int类型）
  - 值
- python中方法和函数是有区别的，函数是.py文件中定义的函数，方法是类中定义的函数

```python
# a 是一个变量，1是一个值（一个int类型的值） a指向1，a这个变量是什么后面会讲到
a = 1
id(a)

# None全局只有一个
a = None
b = None
id(a) == id(b)		# True
```

##### 7.魔法函数

- 在python的class中以双下划线开头,双下划线结尾的函数
- 魔法函数是用来对我们的类进行增强的
- 一般我们不要自定义双下划线的函数，而使用python内置的双下划线的魔法函数

###### getitem魔法函数

```python
# __getitem__魔法方法
class Company(object):
  def __init__(self,employee_list):
    self.employee = employee_list
  
  # 实现__getitem__方法，即可直接对这个类的实例对象进行for循环遍历
  # 实现这个方法，这个类实例化出来的对象就是可迭代对象、
  # __getitem__会从self.employee中一个个取值，直至抛出异常
  def __getitem__(self,item):
    return self.employee[item]

company = Company(['tom','bob','jane'])

# 直接对em进行遍历，会去找__getitem__方法。
for em in company:
  print(em)

# 同时实现了__getitem__它也就是序列类型了 [:2] 取前面两个
com1 = company[:2]
print(com1)					# ['tom', 'bob']

# 也可以适用len打印它的长度. len默认回去找__len__函数，如果没有，则去__getitem__中找，知到它抛出异常，item那个数就是len
print(len(company))


# 如果实现了__len__方法，则len(company)的时候，会直接去找这个函数，然后返回
__len__(self):
    return len(self.employee)
```

###### 8.python的数据模型，以及数据模型对python的影响

- 魔法函数本身的概念是python的数据模型

###### str字符串表示

- 魔法函数是python自己调用的

```python
# str魔法方法，打印该类的实例化对象的时候掉用此方法,默认打印内存地址
def __str__(self):
    return 'name:{}'.format(self.name)

# repr和str一样，reprs是在开发模式中使用的
def __repr__(self):
    return 'name:{}'.format(self.name)
```

###### 8.数学运算

- 数学运算有很多，这里只举两个例子
- 对象都可以进行加减乘除，只要实现对应的魔法方法即可
- len() 函数的特性：在cpython解释器中，当len函数获取list dict set 内置数据类型的长度时，它会去内存中直接读取保存的长度，而不会去遍历。所以一般尽量使用原生的类型，性能高

###### abs魔法函数

```python
# abs属于数学运算的魔法方法，数学运算的魔法方法有很多，这里只举一个例子
class Nums:
    def __init__(self, num):
        self.num = num

    # 当abs(Nums实例) 的时候，会调用这里的方法
    # 直接return 1的话，不管Nums被初始化成什么，都会返回1
    def __abs__(self):
        return abs(self.num)

num = Nums(-10)
# 当执行abs(num)的时候，会去调用__abs__() 魔法方法
print(abs(num))
```

###### add魔法函数

```python
class MyVector:
    def __init__(self,x,y):
        self.x = x
        self.y = y

    # __add__魔法方法，两个对象相加时，进入这个魔法方法
    # 这里返回一个新对象，两个对象的x相加，两个对象的y相加
    def __add__(self, other):
        re_vector = MyVector(self.x + other.x, self.y + other.y)
        return re_vector

    def __str__(self):
        return '(x: {}, y: {})'.format(self.x, self.y)

v1 = MyVector(1,3)
v2 = MyVector(2,4)
print(v1+v2)                # (x: 3, y: 7)
```

##### 9.鸭子类型

- 鸭子类型贯穿我们的python

- python中的魔法方法，正是使用了鸭子函数的特性，所以在python中的很多内置类中都实现了许多魔法方法

```python
# 具有相同的方法就是鸭子类型
class Cat:
    def say(self):
        print('i am a cat')

class Dog:
    def say(self):
        print('i am a dog')

class Duck:
    def say(self):
        print('i am a duck')

# 以上三个类都有一个共同的函数就是鸭子类型。python中实现多态，定义相同的方法即可
# 如果是java则需要定义一个Animal父类，然后子类重写say方法，然后将子类实例对象赋值给Animal类型变量

animals = [Cat, Dog, Duck]
for animal in animals:
    animal().say()

```

##### 10.列表的 extend方法

```python
a = [1,2,3,4]
b = [5,6,7,8]

# extend接收一个可迭代对象，那么字典，set都可以当作参数传递进去
# 自定义的类，只要实现了__getitem__方法，那么这个类的实例化对象也可以传递进去
a.extend(b)

# 如果继承object可省略
class Company(object):
    def __init__(self, employee_list):
        self.employee = employee_list

    # 实现__getitem__方法，即可直接对这个类的实例对象进行for循环遍历
    # 实现这个方法，这个类实例化出来的对象就是可迭代对象
    def __getitem__(self, item):
        return self.employee[item]

    # __le__ 魔法方法，调用len()方法时进入这个函数
    def __len__(self):
        return len(self.employee)

c1 = Company(['tom','jerry','jane'])
a.extend(c1)

print(a)			# [1, 2, 3, 4, 5, 6, 7, 8, 'tom', 'jerry', 'jane']
```

##### 11.抽象基类 [ABC模块]（类似java的接口）

- 抽象基类不可以实例化，继承抽象基类的类，必须实现里面的抽象方法
  - 我们在某些情况之下希望判定某个对象的类型，用抽象基类
  - 我们需要强制子类必须实现某个方法，用抽象基类
- python中变量只是一个符号，可以接收任何对象，所以在python中没有多态的概念，语言本身就是多态的
- 动态的语言，变量不需要声明类型。无法做类型检查，所以有些错误只能在运行是发现，这也是动态语言的缺陷

```python
# python中使用hasattr()判断一个对象是否有某个属性，函数也是属性。返回值为bool
com = Company()
hasattr(com,'__len__')
```

###### 模拟一个抽象基类

```python
# 模仿抽象基类的抽象方法
class CacheBase():
    # 如果子类，不重写这个方法，而调用，则抛出异常
    def get(self, key):
        raise NotImplementedError
    def set(self, key, value):
        raise NotImplementedError

 # 这种模拟的缺陷就是，当只有调用方法的时候，才会抛出异常，而我们的抽象基类，只要继承它，而不实现抽象方法，就会抛出异常
```

###### 抽象基类

- abc模块实现抽象基类
- 在python中尽量使用鸭子类型，抽象基类少用

```python
import abc

# 定义抽象基类，指定metaclass为abc.ABCMeta
# 方法上加 @abc.abstractmethod装饰器，那么这个方法就是抽象方法
class CacheBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def get(self, key):
        pass

    @abc.abstractmethod
    def set(self, key, value):
        pass

# 继承抽象基类，需要实现抽象方法，否则实例化对象的时候会报错
class Redis(CacheBase):
    def get(self, key):
        pass

    def set(self, key, value):
        pass

# 实例化子类
Redis()
```

##### 12.instance 和 type 的区别

- 尽量使用instance 而不是type

```python
# 尽量使用instance 而不是type
class A:
    pass

class B(A):
    pass

b = B()

# isinstance回去检查继承类，所以arg2是父类类型，也为True
print(isinstance(b, B))          # True
print(isinstance(b, A))          # True

# python中is判断对象的地址是否相同，即是不是同一个对象
# == 判断值是否相同
print(type(b) is B)              # True
print(type(b) is A)              # False
```

##### 13.类变量和实例变量

```python
class A:
    # aa其实是类变量,只有一份，是实例所共享的
    aa = 1

    # self代表的是实例，所以self.x和self.y是实例变量
    def __init__(self, x, y):
        self.x = x
        self.y = y

a = A(1, 2)

# 类变量可以通过 类名. 访问，也可以通过 实例. 访问
print(A.aa)
print(a.x, a.y, a.aa)

b = A(1,2)
b.aa = 12

# 类变量只有一份，当A改变之后，实例中找aa也改变了， 实例改变不了类变量
A.aa = 12
print(a.aa)
print(b.aa)

# 当通过实例去修改类变量时，并不会改变类变量aa，而是会在该对象中创建一个实例变量aa
a.aa = 30
```

##### 14.类和属性查找顺序

- 即如果需要在父类中查找某个方法或属性时，它的查找顺序。了解这个在继承的类中有多个同名的方法和属性的时候，就可以知到使用的时哪个类中的犯法

###### 棱形继承查找顺序

```python
# 棱形继承 class A(object)   不写(object)默认也是继承object,这在python3中叫新式类
# class D(B,C) 查找顺序 D B C A
	 |----- B-----
D -- |			 |------A
	 |----- C-----
class A:
    pass
class B(A):
    pass
class C(A):
    pass

class D(B,C):
    pass

# __mro__ 查看属性查找顺序 D B C A
print(D.__mro__)
```

###### 分支查找顺序

```
# class A(B,D)     查找顺序为A B C D E  
	|----B-----C
A --|
	|----D-----E
```

##### 15.静态方法，类方法，对象方法 以及参数

- 实例方法，定义在类中即可，有一个self参数，代表是实例。通过实例调用
- 静态方法，定义在类中，有@staticmethod 装饰器，没有参数
- 类方法，定义在类中，有 @classmethod 装饰器，有cls参数，指向该类

```python
class Date:
    # 构造函数(实例方法)
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # 实例方法
    def __str__(self):
        return '{year}-{month}-{day}'.format(year=self.year,month=self.month, day=self.day)

    # 实例方法
    def tomorrow(self):
        self.day += 1

    # 静态方法，加上@staticmethod装饰，静态方法没有self
    @staticmethod
    def parse_from_string(date_string):
        year, month, day = tuple(date_string.split('-'))
        return Date(int(year), int(month), int(day))

    # 类方法：类方法和静态方法最大的区别就是，它有一个class的参数，指向当前的类
    @classmethod
    def from_string(cls,date_string):
        year, month, day = tuple(date_string.split('-'))
        # 使用类方法，我们就可以使用cls参数，实例化对象，这样做的好处就是，类名改了，这里不需要改变
        # 而上面的静态方法，需要改变
        return cls(int(year), int(month), int(day))

if __name__ == '__main__':
    new_day = Date(2020, 12, 12)
    print(new_day)

    # 通过静态方法（staticmethod）创建对象,静态方法通过类调用
    str_day = Date.parse_from_string('2020-5-24')
    print(str_day)
    
    # 通过类方法进行初始化
    cls_date = Date.from_string('1998-11-20')
    print(cls_date)

```

##### 16.数据封装和私有属性

- 私有属性 __attr
- python的私有并不是绝对安全的，仍然可以通过 _ 类.私有属性 访问 user._User__birthday
- 私有是一种代码规范，即使java这种静态语言，也可以通过反射拿到私有的属性

```python
class User:
    def __init__(self, birthday):
        # 私有属性通过__attr, 给实例变量加 __ 即可
        self.__birthday = birthday

    # 在方法前面加 __ 则成为私有方法,私有方法用来被内部使用
    def __nice(self):
        print(self.__birthday)

    def get_age(self):
        return 2020 - self.__birthday

if __name__ == '__main__':
    user = User(1998)
    print(user.get_age())

    # python的私有化，并不是绝对的私有，只是将私有的属性名字变了
    # 仍然可以通过 _类.私有属性访问
    # print(user._User__birthday)
```

##### 17.python对象的自省机制

- 自省是通过一定的机制，查询对象的内部结构
  - obj.__dict.双下划线	可以得到对象中的属性
  - class.__dict.双下滑线，可以得到类中的属性
  - dir(obj)  dir(class) 可以获取到详细的熟悉

```python
class Person:
    ''' 这里是类的文档 '''
    name = 'user'

class Student(Person):
    def __init__(self,school_name):
        self.school_name = school_name

if __name__ == '__main__':
    s = Student('战争学院')
    # 通过__dict__查询实例中的属性,父类的name没有在这个__dict__中
    print(s.__dict__)                         # {'school_name': '战争学院'}
    s.__dict__['school_name'] = '艾欧尼亚'      # {'school_name': '艾欧尼亚'} __dict__中可以直接修改属性
    print(s.__dict__)
    print(s.name)       # user

    # 可以__dict__查询类中的属性，类中的属性比实例中的属性要丰富的多
    print(Person.__dict__)
    print(Student.__dict__)

    # dir() 可以查看更详细的文档
    print(dir(s))
    print(dir(Student))
```

##### 18.super()函数

- super()调用父类方法

```python
class A:
    def __init__(self):
        print('A')

class B(A):
    def __init__(self):
        print('B')
        # super()获取到父类，再调用父类的__init__()方法
        super().__init__()

if __name__ == '__main__':
    b = B()

'''
    为什么要调用父类的方法: 可以把构造函数交给父类，去实例化
'''
```

##### 19.mixin 混入

- django大量使用了mixin，mixin只定义了方法，相当于java中的接口
- mixin特点
  - Mixin类功能单一
  - 不和基类关联，可以和任意基类组合
  - 在Mixin中不要使用super()这种用法

##### 20.with (上下文管理器)

- with语句是为了让try except finally 更简单的用法

```python
# python中捕捉异常的方式
# 可以加else,在没有异常时执行
try:
    print('coding')
    raise KeyError
except Exception as e:
    print("nice")
    print()
finally:
    print("finally")

# =================================================

# 实现这两个魔法函数,就满足了上下文管理器协议，就可以使用with语句来使用
class Sample:
    # with使用的时候，首先会进入enter方法
    def __enter__(self):
        print('enter')
        print("获取资源")
        return self
    # 跳出with语句之后，会自动执行__exit__方法
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("释放资源")
        print("exit")

    def do_something(self):
        print('doing something')

# 使用with语句
with Sample() as sample:
    sample.do_something()
```

##### 21.contextlib简化上下文管理协议

- 如果对生成器不理解，建议使用上面那种方法

```python
import contextlib
# @contextlib.contextmanager 装饰器可以将我们的函数变成上下文管理器
# 修饰的函数必须是生成器
@contextlib.contextmanager
def file_open(file_name):
    print('file open')
    print("把enter执行的步骤放在yield之前")
    # 必须有一个yield
    yield
    print("把__exit__中执行的步骤放在yeild之后")
    print('file end')

with file_open('bobby.txt') as f:
    print("file processing")
```

##### 22.python中的序列

- python是通过协议编程的，协议就是定义实现了什么方法它就是一个序列，实现了什么方法它就是一个上下文管理器
- 魔法方法凑成了我们的协议
- abc代表 abstract base classes

```python
# 根容器相关的一些数据结构的抽象基类都是放在collections库的abc模块下
from collections import abc
```

###### 序列中  +  +=  extend  append的区别

```python
# +
a = [1, 2]
c = a + [3,4]           # 两个list相加生成一个新的list，只能+list
print(c)                # [1, 2, 3, 4]

# += 就地加              # += 可以接收任何的序列类型
a += [3, 4]             # += 不产生新的对象，在a的基础上+[3,4], 改成(3,4)元组也可
print(a)                # [1, 2, 3 ,4]

# extend               # extend接收一个可迭代对象，没有返回值，直接在a上做修改
a.extend(range(3))     # [1, 2, 3, 4, 0, 1, 2]
print(a)

a.append([1,2,3])       # append是将[1,2,3]当作一个值加到函数中
```

###### 实现可切片对象

- 列表的切片操作会产生一个新的列表，而不会改变原有的列表
- 需要根据序列协议，实现对应的魔法方法即可

```python
# 点进去可以查看，实现可变序列，不可变序列，迭代器需要实现那些抽象方法
import _collections_abc
import numbers
class Group:
    '''支持切片的操作,不可变的序列'''
    def __init__(self, group_name, company_name, staffs):
        self.group_name = group_name
        self.company_name = company_name
        # staffs为一个数组
        self.staffs = staffs

    def __reversed__(self):
        self.staffs.reverse()

    # __getitem__是支持可切片的关键，只要实现这个就可以进行切片了
    def __getitem__(self, item):
        # 取到当前都对象的class
        cls = type(self)
        if isinstance(item, slice):
            return cls(group_name=self.group_name, company_name=self.company_name, staffs=self.staffs[item])
        elif isinstance(item, numbers.Integral):
            return cls(group_name=self.group_name, company_name=self.company_name, staffs=[self.staffs[item]])

    def __len__(self):
        pass

    def __iter__(self):
        return iter(self.staffs)

    def __contains__(self, item):
        if item in self.staffs:
            return True
        else:
            return False

staffs = ['bobby1', 'imooc', 'nice', 'django']
group = Group(company_name='imooc', group_name='users', staffs=staffs)

# 实现了__getitem__方法，可切片，返回的还是可切片的对象
print(group[:2])
print(group[1])

# 实现了__container__方法，可以使用in判断
print('nice' in group)

# 实现了__iter__方法，可迭代
for item in group:
    print(item, end="   ")

print()
# 实现了__reserve__方法，这里就会进入__reserve__魔法方法
reversed(group)
for item in group:
    print(item, end="   ")
```

###### 维护排序列表bisect

```python
import bisect

''' 用来处理已排序的序列，用来维持已排序的序列， 升序 '''

# bisect使用二分查找,所以它的效率比较高
inner_list = []

# 在开发中如果需要使用一个可维护的序列，建议使用bisect,并且二分查找性能比较高
# 通过bisect的insort方法，往inner_list中插入随机插入五个数据
bisect.insort(inner_list, 3)
bisect.insort(inner_list, 2)
bisect.insort(inner_list, 5)
bisect.insort(inner_list, 1)
bisect.insort(inner_list, 6)

# insort其实是insort_right方法，当有同样的元素，它会在在同样的元素后面插入
bisect.insort(inner_list, 3)

# 如果使用insort_left则会找到相同的元素前面插入

# 打印序列，它是排序后的序列 [1, 2, 3, 3, 5, 6]
print(inner_list)
```

###### array数组的使用

- array适合用来存储单一类型的数据，它的效率比list要快

```python
# Array是数组，它的存储是连续的内存空间，它的性能比list高
import array

'''
    array只能存放指定的数据类型
'''

# 'i' 代表是int类型
my_array = array.array('i')

my_array.append(1)
my_array.append(2)

print(my_array)

for i in my_array:
    print(i)
```

###### 列表推导式，生成器表达式，字典推导式

```python
'''
列表推导式  生成器表达式   字典推导式
'''

# 列表推导式,列表推导式的性能高于列表操作
ls1 = [i*3 for i in range(10)]
print(ls1)

# 列表推导式，还需判断 i%2 == 1
ls2 = [i for i in range(20) if i%2 == 1 ]
print(ls2)

# 逻辑复杂的列表生成式,即列表生成式中再调用函数
def pow1(item):
    return item * 2 / 1.5
ls3 = [pow1(i) for i in range(20) if i %2 == 1]
print(ls3)

# ==============================================

''' 生成器表达式 '''

# 将中括号换成小括号，那么它的返回值就是生成器
gen = (i*3 for i in range(10))
print(type(gen))
for i in gen:
    print(i, end=' ')

print()
# ==============================================

'''字典推导式'''
my_dict = {'flask': 22, 'django': 12, 'java': 22}

reversed_dict = {value:key for key,value in my_dict.items()}
print(reversed_dict)

# ==============================================

'''集合推导式,只写一个就是集合推导式'''
my_set = {i*2 for i in range(20)}
print(my_set)
print(type(my_set))
```

##### 23.python中的set和dict

```python
# get方法,get()方法，如果key不存在，给一个默认值。  直接[]:没有key会报错
d = {'nice':12}
d.get('nice','')

# setdefault方法！！
# 去d中查寻，key为'flask'的value,如果没有则返回默认值'good'
# 返回之后，将 'flask': 'good' 添加进d中
a = d.setdefault('flask','good')
print(a)
print(d)

# update方法，将两个dict合并
d.update({'vue': '由于系'})
print(d)

# 这种方式也可以合并
d.update(name='nice')

# 这种方式合并也可以，数组里面放元组
d.update([('不错','可以'), ('厉害', '确实')])
print(d)
```

###### 不建议直接继承list或者dict等用c语言实现的内置类

```python
'''我们不建议去继承list dict set等用c语言实现的内置类'''

# 不建议直接去继承dict,我们可以去继承UserDict
from collections import UserDict

class MyDict(UserDict):
    def __setitem__(self, key, value):
        return super().__setitem__(key, value*2)

# one=1 就相当于 {'on2': 1}
my_dict = MyDict(one = 1)
print(my_dict)                # {'one': 2}
```

##### 24.不可变集合frozenset

```python
# frozenset接收一个可迭代对象。因为frozenset不可变，所以可以当作字典的key
fs = frozenset('hello')

# set的update方法
# update更新集合，接收一个可迭代对象，将里面的内容添加到自己中
s.update([1,2,3])
```

##### 25.dict和list的对比

- dict的查找性能远远大于list
- 再list随着list数据的增大，查找事件会增大
- 在dict中查找元素不会随着dict的增大而增大
- dict的key是由hash实现的，所以不可hash的对象不可以作为dict的key
- set和dict的实现原理是一样的，所以dict的key和set的值都必须是可hash得
- 不可变对象都是可hash的，不如str, frozenset, tuple。
- 自己实现的类 ，实现 __hash双下划线 方法，就是一个可hash的对象
- dict的内存花销打，但是查询速度快，自定义的对象或者python的内部对象，都是dict包装的

##### 26.python的变量到底是什么

```python
'''
    python中的变量和java的实质是不一样的
        python的变量实际上是一个指针，指针的大小是一样的，它可以指向我们的str
        也可以指向int,也可以指向一个对象，它可以指向任何的对象

        python先 生成对象，然后再把指针(变量)，指向这个生成的对象
'''

a = [1, 2, 3, 4, 5]
b = a

# True，a和b是同一个对象，修改a, 那么b的值也会改变
print(a is b)
```

##### 27. == 和 is 的区别

- == 判断它们的值是否相等， is 判断它们的id是否是一样的，即判断它们的内存地址

```python
''' == 调用的是对象内部的__eq__魔法方法 '''
```

##### 28.del语句和垃圾回收

```python
'''
python中垃圾回收的算法是采用引用计数,等引用计数为0时，从内存中删除对象
__del__ 魔法函数，当python解释器回收对象时，会调用__del__模仿方法
'''
a = 1       # 计数器为1
b = 1       # 计数器为2
c = 1       # 计数器为3

del a       # 计数器-1 = 2
del b       # 计数器-1 = 1
del c       # 计数器-1 = 0
```

##### 29.传递参数的时候，尽量不要传递list，否则list的值是会被修改的

```python
''' 演示: 同一个函数，传递不同的数据，对原数据的影响不同,传递参数的时候，最好不要传递lsit
    否则原list的值是会被修改的
 '''
def add(a, b):
    a += b
    return a
```

### 元类编程

##### 1.propert动态属性

```python
from datetime import date,datetime

class User:
    def __init__(self, name, birthday):
        self.name = name
        self.birthday = birthday
        # _age代表不想对外暴露，而时通过属性描述符或者其他方式进行访问
        self._age = 0

    # 加上property装饰器，它就会变成一个属性描述符(python的计算属性)
    # 相当于get
    @property
    def age(self):
        return datetime.now().year - self.birthday.year

    # 相当于set方法
    @age.setter
    def age(self, value):
        self._age = value

''' 这里是测试代码，被别的地方导入的时候，这里的代码不会执行 '''
if __name__ == '__main__':
    user = User('ch-zn',date(year=1998, month=1, day=1))
    # 取@property中的值
    print(user.age)

    # 可以通过属性赋值的方式，调用@age.setter的值
    user.age = 30
```

##### 2.getattr 和 getattribute

```python
'''
__getattr__方法是python解释器内部本身要用的方法，是python动态特性的根本原因
__getattribute__

__getattr__ 是在查找不到属性的时候调用

__getattribute__ 不管查找任何属性，并且不管该属性存不存在，都会进入这个方法找
这个方法的返回值就是找到的值
'''

class User:
    def __init__(self, name):
        self.name = name

    # __getattr__ 当查找的属性，查找不到，则会进入这个方法查找
    def __getattr__(self, item):
        return 'not found attr!'

    # __getattribute__尽量不要重写这个方法
    def __getattribute__(self, item):
        return 'nice'

if __name__ == '__main__':
    u = User("nice")
    # 查找不到age,则会取__getattr__方法，getattr方法返回一个'not found attr'
    print(u.age)
```

##### 3自定义属性描述符

```python
'''
只要实现__get__  __set__  __delete__ 任意一个方法的类，它就是属性描述符
'''
import numbers
class IntField:

    # __get__方法，__set__方法中设置的值
    def __get__(self, instance, owner):
        return self.value

    # __set__ 方法，要求传递的值必须是数字
    def __set__(self, instance, value):
        if not isinstance(value, numbers.Integral):
            raise ValueError("需要传递int进来")
        self.value = value
    def __delete__(self, instance):
        pass


class User:
    # 1.age的值为上面自定义属性描述符的实例
    age = IntField()

if __name__ == '__main__':
    user = User()
    # 2.这里会进入属性描述符的__set__方法，
    user.age = 12
    # 3.这里会进入属性描述符的__get__方法
    print(user.age)
    pass
```

##### 4.init和new魔法方法的区别

```python
'''
__new__ 和 __init__ 的区别

__new__是用来控制对象的生成过程，在对象生成之前
__init__是用来完善对象的，如果__new__方法不返回对象，则不会调用__init__函数
'''

class User:
    # __new__方法，允许我们在生成类对象之前加逻辑,new是在生成对象之后，
    # __init__是生成对象之后，所作的事
    def __new__(cls, *args, **kwargs):
        print('in new')
        # __new__中需要返回对象，否则不会进入init函数，调用父类的方法创建对象并返回
        return super().__new__(cls)

    def __init__(self, name):
        print('in init')
        self.name = name

if __name__ == '__main__':
    # 这里的参数，只传递到__init__中，不传递进__new__中
    u = User('spark')
```

##### 5.元类

```python
''' 类是对象，type创建类的类 '''
# 动态的创建类，使用函数
def create_class(name):
    if name == 'user':
        class User:
            def __str__(self):
                return 'user....'
        # 将类对象返回，即将类返回
        return User
    elif name == 'company':
        class Company:
            def __str__(self):
                return 'company....'
        return Company

if __name__ == '__main__':
    MyClass = create_class('user')
    c = MyClass()
    print(c)
```

##### 6.type动态的创建类

```python
# arg1: 创建的类的名称
# arg2: tuple,传递类所继承的基类,元组只有一个值时，最后必须加逗号
# arg3: dict, 定义类的属性,自定义属性
if __name__ == '__main__':
    User = type('User', (object,), {'name': 'user'})
    my_user = User()
    print(my_user.name)
```

##### 7.type添加类的时候，添加方法

- type --> class --> object

```python
def say(self):
    return 'i say you bilibili'

if __name__ == '__main__':
    User = type('User', (object,), {'name': 'user', 'say': say})
    my_user = User()
    print(my_user.name)
    print(my_user.say())
```

##### 8.自定义元类

```python
'''
自定义元类
python中类的实例化(注意不是对象的实例化，而是类对象的实例化)过程:
    1.首先会寻找metaclass，通过metaclass去创建类对象
    2.如果找不到metaclass则取父类中找metaclass
    3.如果父类中找不到metaclass会去模块中找metaclass
    4.模块中也找不到则使用type实例化类对象
'''

# 继承自type它就是元类,这个类就是为了控制User类实例化的过程
class MyMetaClass(type):
    def __new__(cls, *args, **kwargs):
        return super().__new__(cls, *args, **kwargs)

# 指定创建User时使用的时哪个元类，这里为自定义的MyMetaClass元类
class User(metaclass=MyMetaClass):
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

if __name__ == '__main__':
    u = User(name='self')
    print(u.name)
```

### 迭代器和生成器

##### 1.什么是迭代器

```python
'''
	迭代器是访问集合内元素的一种方式，一般用来遍历数据
	迭代器和以下标的访问方式不一样，迭代器是不能返回的，迭代器提供了一种惰性访问数据的方式
	凡是可迭代的类型都是实现了可迭代协议的（即实现魔法方法 __iter__）
'''

# Iterator是我们的迭代器，它继承了Iterable这个抽象基类
# 继承Iterable抽象类有两个方法必须实现，__iter__   __next__
# __iter__是返回我们的迭代器的， __next__是访问我们的下一个数据的

# 可迭代类型和迭代器是不一样的，可迭代类型实现__iter__即可，迭代器还需实现__next__方法
from collections.abc import Iterable,Iterator

a = [1,2]
print(isinstance(a, Iterable))      # True是可迭代类型
print(isinstance(a, Iterator))      # False不是可迭代对象
```

##### 2.迭代器和可迭代对象的区别

```python
'''
	迭代器是访问集合内元素的一种方式，一般用来遍历数据
	迭代器和以下标的访问方式不一样，迭代器是不能返回的，迭代器提供了一种惰性访问数据的方式
	凡是可迭代的类型都是实现了可迭代协议的（即实现魔法方法 __iter__）
'''

# Iterator是我们的迭代器，它继承了Iterable这个抽象基类
# 继承Iterable抽象类有两个方法必须实现，__iter__   __next__
# __iter__是返回我们的迭代器的， __next__是访问我们的下一个数据的

# 可迭代类型和迭代器是不一样的，可迭代类型实现__iter__即可，迭代器还需实现__next__方法
from collections.abc import Iterable,Iterator

a = [1,2]
print(isinstance(a, Iterable))      # True是可迭代类型
print(isinstance(a, Iterator))      # False不是可迭代对象

# iter()函数接收一个可迭代类型，返回一个迭代器
iter_a = iter(a)
print(isinstance(iter_a, Iterator))
```

##### 3.iter()方法

```python
class Company:
    def __init__(self,employee_list):
        self.employee_list = employee_list
	
    # 参数item是一个索引值
    def __getitem__(self, item):
        return self.employee_list[item]

if __name__ == '__main__':
    company = Company(['tom','bom','vom'])

    # iter()方法首先回去查找company中有没有__iter__方法
    # 如果没有的话，会创建一个默认的迭代器，这个迭代器会利用__getitem__进行遍历
    iter(company)

    # 如果这里遍历的时候连 __getitem__ 都找不到的话，就会抛出异常
    for item in company:
        print(item)
```

##### 4.自定义迭代器

```python
from collections.abc import Iterator
'''自定义迭代器可以继承Iterator, 也可以实现迭代器协议，即魔法方法，迭代器用来做迭代的，不是用来做切片的'''
class MyIterator:

    def __init__(self,my_list):
        self.my_list = my_list
        # 维护一个默认的变量0
        self.index = 0

    # 迭代器中直接return self即可
    # 如果继承了Iterator则不需要实现此方法，只需要实现__next__方法即可
    def __iter__(self):
        return self

    # 真正返回迭代值得逻辑
    def __next__(self):
        # 这里是会抛出一个异常的，因为不断迭代my_list,索引值不断增大，最后就会超过list的大小
        # 从而抛出异常
        try:
            word =  self.my_list[self.index]
        except IndexError:
            raise StopIteration
        self.index += 1
        return word

# 可迭代对象
class Company:
    def __init__(self,employee_list):
        self.employee_list = employee_list


    # __iter__方法需要返回一个迭代器，所以我们使用自己定义的迭代器
    def __iter__(self):
        return MyIterator(self.employee_list)

if __name__ == '__main__':
    company = Company(['tom','bom','vom'])

    for item in company:
        print(item)

```

##### 5.生成器函数的使用

- 生成器为我们的惰性求值（延迟求值）和 协程 提供了可能

```python
'''生成器函数： 函数里只要有yield关键字，它就是一个生成器函数'''
def gen_func():
    yield 1
    yield 2
    yield 3

if __name__ == '__main__':
    # 生成器函数返回的是一个生成器对象,python编译字节码的时候就产生了
    gen = gen_func()
    # 生成器对象也是实现了迭代器协议，所以我们可以使用next()方法获取值，或者通过循环获取值
    print(next(gen))
```

##### 6.生成器实现斐波那契数列

```python
'''普通函数实现斐波那契'''

# 求斐波那契第index的值
def fib(index):
    if index <= 2:
        return 1
    else:
        return fib(index-1) + fib(index-2)

# 求斐波那契数列到index的所有值
def fib2(index):
    re_list = []
    n,a,b = 0,0,1
    while n<index:
        re_list.append(b)
        a,b = b, a+b
        n += 1
    return re_list

# 迭代器实现斐波那契数列
# 内部没有使用List,不会消耗内存，计算完之后直接yield
def gen_fib(index):
    n,a,b = 0,0,1
    while n<index:
        yield b
        a,b = b, a+b
        n += 1

if __name__ == '__main__':
    print(fib(20))
    print(fib2(20))

    for data in gen_fib(10):
        print(data)
```

##### 7.生成器原理

````python
'''
python中函数的工作原理：
    python.exe(python解释器)会用一个叫PyEval_EvalFramEx(c语言函数)去执行foo函数
    首先会创建一个栈帧(堆栈)，
'''

'''堆的意思就是，如果你不释放它，它就会一直存在在我们的内存中'''

# 生成器函数可以有return
def gen_func():
    yield 1				# 生成器对象第一次next()停在这里并记录位置
    name = 'python'
    yield 2				# 第二次next,从上一次记录的位置继续执行，到这里停住，记录位置
    age = 12
    return 'nice'		# 第三次next,返回'nice'
````

##### 生成器原理

```python
''' 堆的意思就是，如果你不释放它，它就会一直存在在我们的内存中'''
''' 生成器函数也会生成栈帧，进入我们的堆内存，独立于调用者之外 '''
''' 只要我们拿到生成器对象就可以控制它一直往前走，在任何地方都可以暂停它恢复它(协程的实现原理) '''
def gen_func():
    yield 1
    name = 'python'
    yield 2
    age = 12
    return 'nice'

gen = gen_func()
print(next(gen))
print(next(gen))
print(next(gen))
```

##### 7.生成器的应用场景

```python
from collections import UserList
''' List是用C语言实现的，而UserList是用python语言实现的，我们尽量不要继承List
    而选择去继承UserList,这样我们就可以覆盖它的任何函数
    
    UserList的__iter__使用了yield生成器的方式，来进行遍历
 '''
```

##### 8.yield读取大文件的应用

```python

```

## socket

###### server

```python
import socket

# 1.arg1:指定使用的是ipv4, arg2:代表使用的是TCP
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2.0.0.0.0代表本机所有地址，局域网的其他IP也可以访问到，如果写127.0.0.1则局域网内其他pc访问不到
server.bind(('0.0.0.0', 8000,))

# 3.监听
server.listen()

# 4.接收用户连接请求,会获取两个返回值
# arg1: socket arg2:address
sock, addr = server.accept()

# 5.获取从客户端发送过来的数据,一次获取1k的数据
data = sock.recv(1024*10)

# 6.节码成utf8并打印
print(data.decode('utf8'))

# 7.发送数据给client
sock.send('嗯嗯，确实很nice'.encode('utf8'))

# 7.关闭资源
server.close()
sock.close()

```

###### client

```python
import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 1.连接本机的8000端口,因为server也是在本机启动的
client.connect(('127.0.0.1', 8000))

# 2.发送数据
client.send('nice! 干的漂亮'.encode('utf8'))

# 3.接收server发送的数据
data = client.recv(1024)
print(data.decode('utf8'))

# 3.关闭资源
client.close()
```

## 多线程

##### 1GIL

```python
''' gil(global interpreter lock) 解释器是cpython
    python中一个线程对应c语言中的一个线程
    gil使得同一时刻只有一个线程运行在一个cpu上执行字节码(python也会编译成字节码)
    GIL使得无法将多个线程运行在多个cpu上
    GIL会根据执行的字节码函数以及时间片释放gil,gil会在遇到io操作的时候，主动释放GLI这个全局锁
    所以python的多线程在IO操作频繁的情况下，是非常使用的，但是不适用于计算密集型的任务
'''

total = 0

def add():
    global total
    for i in range(1000000):
        total += 1

def desc():
    global total
    for i in range(1000000):
        total -= 1

import threading
thread1 = threading.Thread(target=add)
thread2 = threading.Thread(target=desc)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# 每次运行的total不一致，线程之间相互切换，修改同一个变量，导致线程不安全的问题
print(total)
```

##### 函数实现多线程

```python
''' 对于IO操作来说,多线程和多进程性能差别不大,多线程比多进程更加轻量级 '''

import threading
import time

def nice(arg1):
    time.sleep(2)
    print(arg1)

# 1.通过Thread实例化
if __name__ == '__main__':
    # arg2是元组,如果只有一个参数,需要在最后加,
    thread1 = threading.Thread(target=nice, args=('threading1',))
    thread2 = threading.Thread(target=nice, args=('threading2',))

    # 设置为守护线程,当主线程退出之后,直接将守护进程kill掉
    # thread1.setDaemon(True)
    # thread2.setDaemon(True)

    thread1.start()
    thread2.start()

    # join加入线程,会阻塞在这里,在这里执行后才会执行后面的代码
    thread1.join()
    thread2.join()

    print('main threading......')
```

##### 继承实现多线程

```python
''' 函数实现多线程适用于代码量少逻辑简单的时候
    类实现多线程适用于代码量大,逻辑复杂的时候
'''

import time
import threading

# 继承Thread, 实现run方法即可
class MyThread(threading.Thread):
    # __init__方法,调用父类的init方法
    def __init__(self,name):
        super().__init__(name=name)

    def run(self):
        time.sleep(2)
        print(self.name)

if __name__ == '__main__':
    thread1 = MyThread('MyThread1....')
    thread2 = MyThread('MyThread2....')

    # 默认主线程会在子线程kill掉后,才kill掉
    thread1.start()
    thread2.start()
```

##### 线程间通信(Queue)

```python
import threading
import time
import random
from queue import Queue
'''通过queue的方式进行线程间的通信'''

ls = []

def thread1(my_queue):
    print('threading1......')
    for i in range(20):
        my_queue.put(i)

def thread2(my_queue):
    for i in range(20):
        print(my_queue.get())


if __name__ == '__main__':
    my_que = Queue(maxsize=1000)

    threading1 = threading.Thread(target=thread1, args=(my_que,))
    threading2 = threading.Thread(target=thread2, args=(my_que, ))

    threading1.start()
    threading2.start()
```

##### 线程同步Lock

- Lock锁会影响性能, 锁会引起死锁
- 死锁: 

```python
import threading
from threading import Lock

'''线程同步(锁),让用以时间,只有一段代码在执行'''
# 创建一把锁
lock = Lock()
total = 0

def add():
    global total
    global lock
    for i in range(1000000):
        # 获取锁
        lock.acquire()
        total += 1
        #释放锁
        lock.release()

def desc():
    global total
    global lock
    for i in range(1000000):
        lock.acquire()
        total -= 1
        # 释放锁
        lock.release()

thread1 = threading.Thread(target=add)
thread2 = threading.Thread(target=desc)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# 每次运行的total一致,因为加了锁
print(total)
```

##### 线程同步RLock(不会产生死锁问题)

```python
import threading
from threading import Lock,RLock

''''''
# 创建一把锁Rlock: 在同一个线程里,可以连续多次调用acquire, acquire和release的次数要一致
lock = RLock()
total = 0

def add(lock):
    global total
    for i in range(1000000):
        # 获取锁
        lock.acquire()
        total += 1
        #释放锁
        lock.release()

def desc(lock):
    global total
    for i in range(1000000):
        # 获取锁
        lock.acquire()
        total -= 1
        # 释放锁
        lock.release()

thread1 = threading.Thread(target=add, args=(lock, ))
thread2 = threading.Thread(target=desc, args=(lock, ))

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# 每次运行的total不一致，线程之间相互切换，修改同一个变量，导致线程不安全的问题
print(total)
```

##### condition(条件变量)  用于复杂的线程间同步,是python中最复杂的锁

```python
from threading import Condition
import threading

''' condition条件变量,是python中最复杂的锁, wait和notify是一一对应的 '''

# 让小爱和天猫一人执行一步
class XiaoAi(threading.Thread):
    def __init__(self, condition):
        super().__init__(name='小爱')
        self.condition = condition

    def run(self):
        with self.condition:
            self.condition.notify()
            print('{}: 在'.format(self.name))
            self.condition.wait()
            print('小爱: 好呀')
class TianMao(threading.Thread):
    def __init__(self, condition):
        super().__init__(name='天猫精灵',)
        self.condition = condition

    def run(self):
        with self.condition:
            print('{}: 小爱同学'.format(self.name))
            self.condition.wait()
            print('天猫精灵: 我们来对古诗吧!')
            self.condition.notify()

if __name__ == '__main__':
    # 创建condition对象
    condition = Condition()
	
    # 将condition传递给我们的线程
    xiaoai = XiaoAi(condition)
    tianmao = TianMao(condition)

    # 启动顺序很重要
    tianmao.start()
    xiaoai.start()
```

##### 信号量Semaphore

```python
import threading
import time
from threading import Semaphore

''' 
信号量(semaphore): 是用于控制进入数量的锁
比如文件读写:
    写: 一般只允许一个线程写
    读: 允许多个线程读
'''

class HtmlSpider(threading.Thread):


    def __init__(self, semaphore):
        super().__init__()
        self.semaphore = semaphore

    def run(self):
        time.sleep(2)
        print('get html text success...')
        # 爬虫完成后release
        self.semaphore.release()

class UrlProducer(threading.Thread):

    def __init__(self, semaphore):
        super().__init__()
        self.semaphore = semaphore

    def run(self):
        for i in range(20):
            # acquire会将传递过来的信号量-1,减到0会wait
            self.semaphore.acquire()
            html_thread = HtmlSpider(self.semaphore)
            html_thread.start()

if __name__ == '__main__':
    # 创建semaphore, 3代表允许三个并发
    semaphore = Semaphore(3)
    url_producer = UrlProducer(semaphore)
    url_producer.start()
```

##### 线程池

```python
'''futures是专门用来做线程池和进程池编程的'''
from concurrent.futures import ThreadPoolExecutor
import time
'''
为什么要线程池:
    可以管理我们的线程,并且可以自己进行调度,并且线程池里的线程可复用,
    当一个线程完成时,我们的主线程能立即知到线程完成,也可以用到线程池
    futures可以让多线程和多进程编码接口一致
'''
def get_html(times):
    time.sleep(times)
    print('get page {} s'.format(times))
    return times

# 实例化一个线程池
# arg: 同时最多运行两个线程
executor = ThreadPoolExecutor(max_workers=2)

# 通过submit函数提交执行的函数到线程池, arg1:函数名, arg2:函数的参数
# 提交之后会有一个返回值,很重要
task1 = executor.submit(get_html, (3))
task2 = executor.submit(get_html, (3))

# task的done获取线程的执行,状态, False还没执行成功,因为函数中sleep了
print(task1.done())
print(task2.done())

# result可以获取线程执行的最终结果,是一个阻塞的方法
print('result:', task1.result())

# True, sleep 4秒之后,提交的线程都完成了
time.sleep(4)
print(task1.done())
print(task2.done())
```

##### 获取到已经成功的task的返回值

```python
from concurrent.futures import ThreadPoolExecutor, as_completed,wait
import time

def get_html(times):
    time.sleep(times)
    print('get page {} s'.format(times))
    return times

executor = ThreadPoolExecutor(max_workers=2)

# 批量的提交任务
urls = [2, 3, 4,]
all_task = [executor.submit(get_html, (url)) for url in urls]

# 1.as_completed 获取已经成功的task`
for future in as_completed(all_task):
    # 获取到线程的返回
    data = future.result()
    print(data)

# wait让主线程阻塞,等执行完参数里面的线程,再往后执行代码, 这里all_task是所有的线程
wait(all_task)
print('main')

# 2.executor可以让我们更轻松获取到成功的task的返回
# for data in executor.map(get_html, urls):
#     print(data)

```

###### 多进程

- [2]*30	返回30个2的列表
- 进程也分主进程和子进程
- 子进程和父进程的数据是独立的,各子进程的数据也是独立的,会从父进程中拷贝一份
- 父进程退出之后,子进程仍然可以执行

```python
# 多进程: 适用于计算密集型(数学计算,图形计算)的任务, 对于io操作来说,多线程即可
# 进程切换代价要高于线程的切换

from concurrent.futures import ProcessPoolExecutor,as_completed

import time
def MyThread(times):
    print('success -----> {}'.format(times))
    time.sleep(times)
    return times

# 在windows下,使用多进程,一定要在 __name__ == '__main__'中,否则会报错
if __name__ == '__main__':
    with ProcessPoolExecutor(3) as executor:
        all_task = [executor.submit(MyThread, (num)) for num in [2]*5]
        for future in as_completed(all_task):
            print(future.result())
```

##### 进程池

```python
from concurrent.futures import ProcessPoolExecutor,as_completed
import multiprocessing
import time
def my_process(times):
    sum = 0
    time.sleep(times)
    for i in range(10000):
        sum += i
    return sum

if __name__ == '__main__':
    # 有多少个进程,直接获取到cpu的数量,就有多少个进程
    poll = multiprocessing.Pool(multiprocessing.cpu_count())
    result1 = poll.apply_async(my_process, args=(3,))
    result2 = poll.apply_async(my_process, args=(4,))

    # 等待所有任务完成
    # poll.close()表示不再接收新的进程
    poll.close()
    # poll.join一定要在poll.close之后
    poll.join()
    print(result1.get())
    print(result2.get())
```

##### 进程池2  imap

```python
from concurrent.futures import ProcessPoolExecutor,as_completed
import multiprocessing
import time
def my_process(times):
    sum = 0
    time.sleep(times)
    for i in range(10000):
        sum += i
    return sum

if __name__ == '__main__':
    # 有多少个进程,直接获取到cpu的数量,就有多少个进程

    poll = multiprocessing.Pool(multiprocessing.cpu_count())

    for result in poll.imap(my_process, [1,2,3]):
        print(result)

```

##### 进程间通信 Queue

```python
import time
'''多进程包中有Queue,可以实现通信'''
from  multiprocessing import Process, Queue

def push1(q):
    q.put('a')

def get1(q):
    print(q.get())


if __name__ == '__main__':
    q = Queue(10)

    p1 = Process(target= push1, args=(q, ))
    p2 = Process(target= get1, args=(q, ))

    p1.start()
    p2.start()
    p1.join()
    p2.join()
```

##### Manager实现线程池通信

```python
import time
'''多进程包中有Manager,可以实现进程池间通信,Queue不能用于pool进程池'''
from  multiprocessing import Pool,Manager,Queue

def push1(q):
    q.put('a')

def get1(q):
    print(q.get())


if __name__ == '__main__':
    
    # Manager中还有Dict, Array, List, Value等
    q = Manager().Queue(10)

    pool = Pool(2)

    pool.apply_async(push1, args=(q, ))
    pool.apply_async(get1, args=(q, ))

    pool.close()
    pool.join()
```

##### 进程间通信pipe

- pipe的性能要高于queue

```python
import time
'''多进程包中有Manager,可以实现进程池间通信,Queue不能用于pool进程池'''
from  multiprocessing import Pool,Manager,Pipe, Process

def push1(pipe):
    # pipe发送数据使用send方法
    pipe.send('a')

def get1(pipe):
    # pipe接收数据,使用recv方法
    print(pipe.recv())


if __name__ == '__main__':
    # 实例化pipe,会返回两个对象,分别是用来做发送和接收的collection
    # pipe只能适用于两个进程间的通信
    receive_pipe, send_pipe  = Pipe()

    # arg为发送数据的pipe
    p1 = Process(target=push1, args=(send_pipe,))
    # arg为接收数据的pipe
    p2 = Process(target=get1, args=(receive_pipe, ))

    p1.start()
    p2.start()

    p1.join()
    p2.join()

```

##### Manager的dict使用

```python
from multiprocessing import Process,Manager

def set_dict1(dic, key, value):
    dic[key] = value

def set_dict2(dic, key, value):
    dic[key] = value
if __name__ == '__main__':
    dic = Manager().dict()
    p1 = Process(target=set_dict1, args=(dic,'name', 'hcp'))
    p2 = Process(target=set_dict2, args=(dic,'address', 'china'))

    p1.start()
    p2.start()

    p1.join()
    p2.join()

    print(dic)
```

## 协程和异步

##### 生成器进阶(协程的基础)

```python
''' 生成器不仅可以产出值,还可以接受值 '''
def gen_func():
    # 可以产出值(yield后面的值),可以接收值(调用方传递的值),接收之后,赋值给html
    html = yield 'http://www.baidu.com'
    print(html)
    yield 2
    yield 3
    yield 4
    return 'nice'


if __name__ == '__main__':
    gen = gen_func()

    # 在调用send发送非None值之前,我们必须启动一次生成器,方式有两种next(gen) gen.send(None)

    # 1.启动生成器方式有两种: next() send()
    url = next(gen)
    print(url)

    # send方法可以传递值,进入生成器内部,同时还可以重启生成器,执行到下一个位置
    html = 'nice'
    print(gen.send(html))
```

##### 生成器的throw和close

```python
def gen_func():
    yield 'http://www.baidu.com'
    yield 2
    yield 3
    return 'complete'

if __name__ == '__main__':
    gen = gen_func()
    print(next(gen))

    # 生成器close之后,再调用next()会报错,因为close之后,生成器已经结束了
    gen.close()
    next(gen)
```

##### 生成器throw

```python
def gen_func():
    # 捕获throw主动抛出的异常
    try:
        yield 'http://www.baidu.com'
    except Exception as e:
        pass
    yield 2
    yield 3

if __name__ == '__main__':
    gen = gen_func()
    print(next(gen))
    # throw 向生成器抛出异常
    gen.throw(Exception, '主动向生成器抛出异常')
    
    # 生成器内部处理了异常,这里就可以继续执行
    print(next(gen))

```

##### chain方法

```python
''' 可以将两个可迭代的类型连接起来,做一次循环 '''
from itertools import chain

my_list = [1,2,3]

my_dict = {
    'ulr': 'http://www.baidu.com',
    'path': '/store/add'
}

for value in chain(my_list, my_dict, range(5,10)):
    print(value)
```

##### 生成器的yield from (3.3新加特性)

```python
''' 可以将两个可迭代的类型连接起来,做一次循环 '''
from itertools import chain

my_list = [1,2,3]

my_dict = {
    'ulr': 'http://www.baidu.com',
    'path': '/store/add'
}

# yield from 可以将iterable中的值一个一个yield出来,而不再需要一个一个yield
def my_chain(*args, **kwargs):
    for my_iter in args:
        yield from my_iter

for value in my_chain(my_list, my_dict, range(7,9)):
    print(value)
```

##### yield from

```python
def g1(iterable):
    # yield from 会将里面的每一个值给yield出来 
    yield from iterable

def g2(iterable):
    # yield什么值就返回什么值
    yield iterable

if __name__ == '__main__':
    
    for value in g1(range(10)):
        print(value)

    for value in g2(range(10)):
        print(value)
```

##### 原生协程 await async

- 为了使编程语义化,我们尽量使用await和async实现协程而不要使用原生的生成器实现协程

```python
'''
    python为了将语义变得更明确,引入了async和await关键词用于定义原生的协程
'''
async def downloader(url):
    return 'success'

async def download_url(url):
    html = await downloader(url)
    return html

if __name__ == '__main__':
    coro = download_url('http://www.baidu.com')
    # 原生的协程需要使用send调用
    coro.send(None)
```

## 并发编程asyncio

- asyncio在python3.4之后引入,主要是解决并发的编程问题,python最具野心的模块
- 包含各种特定系统实现的模块化事件循环
- 传出和协议抽象
- 对TCP, UDP, SSL, 子进程, 延时调用以及其他的具体支持
- 基于yield from的协议和任务,可以让你用顺序的方式编写并发代码
- 必须使用一个将产生阻塞IO的调用时,有接口可以把这个事件转移到线程池
- 模仿threading模块的同步原语,可以用在单线程内的协程之间
- asyncio可以在多线程之中使用

##### 事件循环 (asyncio最基本的功能)

```python
import asyncio
import time
'''
    asyncio时python用于解决异步io编程的一整套解决方案
    tornado使用了asyncio(实现了web服务器),所以可以nginx+tornado直接部署
    django flask使用 uwsgi, gunicorn + nginx 部署
'''

async def get_html(url):
    print('start get html....')
    # 这里必须要使用await等待它执行完成,且sleep必须要使用asyncio的sleep
    await asyncio.sleep(2)
    print('end get url')

if __name__ == '__main__':

    start_time = time.time()

    # 直接获取事件循环
    loop = asyncio.get_event_loop()
    loop.run_until_complete(get_html('http://www.baidu.com'))

    print(time.time() - start_time)
```

##### 执行10个协程,只需要两秒, 100个协程也是两秒

```python
import asyncio
import time
'''
    asyncio时python用于解决异步io编程的一整套解决方案
    tornado使用了asyncio(实现了web服务器),所以可以nginx+tornado直接部署
    django flask使用 uwsgi, gunicorn + nginx 部署
'''

# 定义协程
async def get_html(url):
    print('start get html....')
    # 这里必须要使用await等待它执行完成,且sleep必须要使用asyncio的sleep
    await asyncio.sleep(2)
    print('end get url')

if __name__ == '__main__':

    start_time = time.time()

    # 直接获取事件循环
    loop = asyncio.get_event_loop()
    # 生成10个协程对象数组
    tasks = [get_html('http://www.baidu.com') for i in range(10)]
    # 将10个协程数组放到loop中执行
    loop.run_until_complete(asyncio.wait(tasks))
    print(time.time() - start_time)
```

##### 获取协程返回值

```python
import asyncio
import time
'''
    asyncio时python用于解决异步io编程的一整套解决方案
    tornado使用了asyncio(实现了web服务器),所以可以nginx+tornado直接部署
    django flask使用 uwsgi, gunicorn + nginx 部署
'''

# 定义协程
async def get_html(url):
    print('start get html....')
    # 这里必须要使用await等待它执行完成,且sleep必须要使用asyncio的sleep
    await asyncio.sleep(2)
    return 'success.......'

if __name__ == '__main__':
    start_time = time.time()
    loop = asyncio.get_event_loop()

    # 直接将协程放在asyncio.ensure_future中
    get_future = asyncio.ensure_future(get_html('http://www.baidu.com'))

    # 这种写法和上面的写法一样使用,也可以通过get_task.result()拿到结果
    # get_task = loop.create_task(get_html('http://www.baidu.com'))

    # 接收future类型
    loop.run_until_complete(get_future)

    # 获取返回值
    print(get_future.result())
    print(time.time() - start_time)
```

##### 协程完成后使用回调函数

```python
import asyncio
import time
'''
    asyncio时python用于解决异步io编程的一整套解决方案
    tornado使用了asyncio(实现了web服务器),所以可以nginx+tornado直接部署
    django flask使用 uwsgi, gunicorn + nginx 部署
'''

# 定义协程
async def get_html(url):
    print('start get html....')
    # 这里必须要使用await等待它执行完成,且sleep必须要使用asyncio的sleep
    await asyncio.sleep(2)
    return 'success.......'

# 默认会传递一个参数进来
def callback(future):
    print('协程执行完成,callback执行....')

if __name__ == '__main__':
    start_time = time.time()
    loop = asyncio.get_event_loop()


    # 创建任务
    get_task = loop.create_task(get_html('http://www.baidu.com'))

    # 添加回调,回调函数为callback, 默认会传递future参数进去
    get_task.add_done_callback(callback)

    # 运行协程任务
    loop.run_until_complete(get_task)

    # 获取返回值
    print(get_task.result())
```

##### 使用回调函数的时候带参数

```python
import asyncio
import time
# 用来将函数封装成带参数的函数,传递给回调函数
from functools import partial

# 定义协程
async def get_html(url):
    print('start get html....')
    await asyncio.sleep(2)
    return 'success.......'

# 主动传递的参数,放在第一个位置
def callback(url, future):
    print(url)
    print('协程执行完成,callback执行....')

if __name__ == '__main__':
    start_time = time.time()
    loop = asyncio.get_event_loop()


    # 创建任务
    get_task = loop.create_task(get_html('http://www.baidu.com'))

    # 回调函数如果想传递参数,必须使用partial将函数封装成一个带参数的函数
    get_task.add_done_callback(partial(callback, 'http://www.baidu.com'))

    # 运行协程任务
    loop.run_until_complete(get_task)

    # 获取返回值
    print(get_task.result())
```

##### async.wait() 和 async.gather()的区别

```python
import asyncio
import time
'''
    asyncio时python用于解决异步io编程的一整套解决方案
    tornado使用了asyncio(实现了web服务器),所以可以nginx+tornado直接部署
    django flask使用 uwsgi, gunicorn + nginx 部署
'''

# 定义协程
async def get_html(url):
    print('start get html....')
    # 这里必须要使用await等待它执行完成,且sleep必须要使用asyncio的sleep
    await asyncio.sleep(2)
    print('end get url')

if __name__ == '__main__':

    start_time = time.time()
    loop = asyncio.get_event_loop()

    # 创建两个任务组
    group1 = [get_html('http://www.baidu.com') for i in range(2)]
    group2 = [get_html('http://www.baidu.com') for i in range(2)]

    # loop.run_until_complete(asyncio.wait(tasks))
    # gather比wait更加高级,gather可以将我们的任务分组
    loop.run_until_complete(asyncio.gather(*group1, *group2))
    
    print(time.time() - start_time)
```

##### 取消future(task)

- 在命令行运行,并且ctrl+c中断,捕捉异常,从而触发取消任务

```python
import asyncio
import time

async def get_html(sleep_times):
    print('wait')
    await asyncio.sleep(sleep_times)
    print('done {} S'.format(sleep_times))

if __name__ == '__main__':
    task1 = get_html(2)
    task2 = get_html(3)
    task3 = get_html(4)

    tasks = [task1, task2, task3]

    loop = asyncio.get_event_loop()

    try:
        loop.run_until_complete(asyncio.wait(tasks))
    except KeyboardInterrupt as e:
        # 获取到所哟的task
        all_task = asyncio.Task.all_tasks()

        for task in all_task:
            print('cancel task')
            # 取消task,会有返回值,True或者False(有没有取消成功),因为正在运行的task是无法取消的
            print(task.cancel())

        # 取消任务之后将loop给stop
        loop.stop()
        # stop之后必须要调用run_forever否则会报错
        loop.run_forever()
    finally:
        loop.close()
```

##### 协程之中嵌套协程

```python
import asyncio

# 定义一个协程
async def compute(x, y):
    print('compute %s + %s ...'% (x, y))
    await asyncio.sleep(2)
    return x+y

# 第二个协程
async def print_sum(x, y):
    # 在这里使用第一个协程
    result = await compute(x,y)
    print('%s + %s = %s' % (x, y, result))

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(print_sum(1,2))
    loop.close()
```

##### asyncio的其他函数

- asyncio可以执行普通的函数

- call_soon()  可以执行普通的函数,并且这个方法是立马执行,即在队列中把它排到第1

```python
import asyncio

def callback(sleep_times):
    print('sleep %s S' % sleep_times)

def stoploop(loop):
    loop.stop()

if __name__ == '__main__':
    loop = asyncio.get_event_loop()

    # 1.call_soon可以插入一个普通函数到队列,立马执行,因为会放到队列的最前面
    loop.call_soon(callback, 2)

    # 2.提交一个停止loop的函数,将loop作为参数传递进去,会帮我们停止这个loop
    loop.call_soon(stoploop, loop)
    # 没有提交的任务,只是要通过call_soon插入一个普通函数到队列,所以使用run_forever
    loop.run_forever()

```

##### call_later方法,在几秒钟之后执行函数

```python
import asyncio

def callback(sleep_times):
    print('sleep %s S' % sleep_times)

def stoploop(loop):
    loop.stop()

if __name__ == '__main__':
    loop = asyncio.get_event_loop()

    # 1.call_later在几秒钟之后执行函数,2秒钟之后执行
    loop.call_later(2, callback, 2)

    # 2. 4秒后执行
    loop.call_later(4, stoploop, loop)
    # 没有提交的任务,只是要通过call_soon插入一个普通函数到队列,所以使用run_forever
    loop.run_forever()
```

##### 线程池(ThreadPollExecutor) 和 asyncio结合

```python
'''
asyncio是异步编程的解决方案,异步IO是包含了我们的多线程,协程和进程的
所以asyncio既可以完成多线程,也可以完成协程,也可以完成进程.协程里不能放阻塞IO的逻辑
所以当有阻塞的IO需要放在asyncio中执行的时候,就可以使用多线程
'''
import asyncio
import time
from concurrent.futures.thread import ThreadPoolExecutor


def compute():
    time.sleep(2)
    print('compute complete')


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor()

    tasks = []

    # run_in_executor 将阻塞IO的函数放到excutor中运行
    for i in range(10):
        task = loop.run_in_executor(executor, compute)
        tasks.append(task)

    start_time = time.time()
    loop.run_until_complete(asyncio.wait(tasks))
    print(time.time() - start_time)
```

##### 





